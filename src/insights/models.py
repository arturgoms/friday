"""
Friday Insights Engine - Data Models

Core dataclasses and enums for the insights system.
"""

from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Optional, Dict, Any, List
import uuid

from src.core.constants import BRT


class InsightType(Enum):
    """Types of insights the system can generate."""
    THRESHOLD = "threshold"      # Something crossed a limit
    ANOMALY = "anomaly"          # Unusual pattern detected
    CORRELATION = "correlation"  # X affects Y relationship
    PREDICTION = "prediction"    # Future projection
    REMINDER = "reminder"        # Calendar, scheduled event
    DIGEST = "digest"            # Summary report (daily/weekly)
    STATUS = "status"            # System status update
    INFO = "info"                # Informational message


class Priority(Enum):
    """Priority levels for insights, affects delivery timing."""
    LOW = "low"           # Add to weekly report
    MEDIUM = "medium"     # Add to daily report  
    HIGH = "high"         # Send when appropriate (respects quiet hours)
    URGENT = "urgent"     # Send immediately (ignores quiet hours)


class Category(Enum):
    """Categories for organizing insights."""
    HEALTH = "health"
    PRODUCTIVITY = "productivity"
    HOMELAB = "homelab"
    CALENDAR = "calendar"
    WEATHER = "weather"
    SYSTEM = "system"
    JOURNAL = "journal"


class DeliveryChannel(Enum):
    """Channels through which insights can be delivered."""
    TELEGRAM = "telegram"
    MORNING_REPORT = "morning_report"
    EVENING_REPORT = "evening_report"
    WEEKLY_REPORT = "weekly_report"


@dataclass
class Insight:
    """
    A single insight generated by an analyzer.
    
    Insights are the core output of the analysis layer. They represent
    observations, alerts, correlations, or predictions that may be
    worth communicating to the user.
    """
    type: InsightType
    category: Category
    priority: Priority
    title: str
    message: str
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    confidence: float = 1.0  # 0-1, for correlations/predictions
    data: Dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=lambda: datetime.now(BRT))
    expires_at: Optional[datetime] = None  # When insight becomes stale
    source_analyzer: str = ""
    dedupe_key: Optional[str] = None  # For deduplication (e.g., "stress_high")
    
    def is_expired(self) -> bool:
        """Check if this insight has expired."""
        if self.expires_at is None:
            return False
        return datetime.now(BRT) > self.expires_at
    
    def __str__(self) -> str:
        return f"[{self.priority.value.upper()}] {self.title}: {self.message}"


@dataclass
class Snapshot:
    """
    Point-in-time data capture for historical analysis.
    
    Collectors store snapshots periodically, which analyzers can then
    query to detect patterns, correlations, and anomalies over time.
    """
    collector: str  # Name of collector that created this
    timestamp: datetime
    data: Dict[str, Any]
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get a value from the snapshot data."""
        return self.data.get(key, default)


@dataclass
class Delivery:
    """
    Record of insight delivery.
    
    Tracks what insights were delivered, when, and through which channel.
    Used for rate limiting and avoiding duplicate deliveries.
    """
    insight_id: str
    channel: DeliveryChannel
    delivered_at: datetime = field(default_factory=lambda: datetime.now(BRT))
    success: bool = True
    error: Optional[str] = None
    id: str = field(default_factory=lambda: str(uuid.uuid4()))


@dataclass
class ReachOutBudget:
    """
    Tracks daily reach-out budget and quiet hours.
    
    Used by the decision engine to limit proactive messages.
    """
    date: str  # YYYY-MM-DD
    count: int = 0
    max_per_day: int = 5
    deliveries: List[str] = field(default_factory=list)  # insight_ids
    
    def can_reach_out(self) -> bool:
        """Check if we can still reach out today."""
        return self.count < self.max_per_day
    
    def record_delivery(self, insight_id: str):
        """Record a delivery against today's budget."""
        self.count += 1
        self.deliveries.append(insight_id)


@dataclass 
class AnalyzerResult:
    """
    Result from running an analyzer.
    
    Contains any insights generated plus metadata about the run.
    """
    analyzer_name: str
    insights: List[Insight] = field(default_factory=list)
    run_at: datetime = field(default_factory=lambda: datetime.now(BRT))
    duration_ms: float = 0
    error: Optional[str] = None
    
    @property
    def success(self) -> bool:
        return self.error is None
