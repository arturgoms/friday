"""
Friday 3.0 Code Interpreter

Provides a persistent Python REPL for executing code generated by the LLM.
Implements the ReAct loop pattern with safety checks.

Usage:
    from src.core.interpreter import CodeInterpreter
    
    interpreter = CodeInterpreter()
    result = await interpreter.execute("print('Hello, world!')")
"""

import asyncio
import io
import logging
import re
import sys
import traceback
from code import InteractiveConsole
from contextlib import redirect_stdout, redirect_stderr
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Set

from .config import get_config

logger = logging.getLogger(__name__)


# =============================================================================
# Safety Patterns
# =============================================================================

# Dangerous patterns that require confirmation
DANGEROUS_PATTERNS = [
    # File system destructive operations
    r"\bos\.remove\s*\(",
    r"\bos\.unlink\s*\(",
    r"\bos\.rmdir\s*\(",
    r"\bshutil\.rmtree\s*\(",
    r"\bshutil\.move\s*\(",
    r"\bpathlib\.Path.*\.unlink\s*\(",
    r"\bpathlib\.Path.*\.rmdir\s*\(",
    
    # Subprocess/shell execution
    r"\bsubprocess\.",
    r"\bos\.system\s*\(",
    r"\bos\.popen\s*\(",
    r"\bos\.exec",
    r"\bos\.spawn",
    
    # Network operations that could be dangerous
    r"\bsocket\.",
    r"\burllib\.request\.urlopen\s*\(",
    
    # Database operations
    r"\.execute\s*\([^)]*(?:DROP|DELETE|TRUNCATE)",
    
    # System modifications
    r"\bos\.chmod\s*\(",
    r"\bos\.chown\s*\(",
]

# Absolutely forbidden patterns (will be blocked, not just confirmed)
FORBIDDEN_PATTERNS = [
    r"rm\s+-rf\s+/\s*$",
    r"rm\s+-rf\s+/\*",
    r":\(\)\s*{\s*:\s*\|\s*:\s*&\s*}\s*;",  # Fork bomb
    r"\beval\s*\(\s*input\s*\(",
    r"__import__\s*\(\s*['\"]os['\"]\s*\)\s*\.\s*system",
]

# Compiled patterns for efficiency
_dangerous_re = [re.compile(p, re.IGNORECASE) for p in DANGEROUS_PATTERNS]
_forbidden_re = [re.compile(p, re.IGNORECASE) for p in FORBIDDEN_PATTERNS]


# =============================================================================
# Execution Result
# =============================================================================

@dataclass
class ExecutionResult:
    """Result of code execution."""
    success: bool
    stdout: str = ""
    stderr: str = ""
    return_value: Any = None
    exception: Optional[str] = None
    requires_confirmation: bool = False
    dangerous_operations: List[str] = field(default_factory=list)
    execution_time: float = 0.0
    
    def to_llm_context(self) -> str:
        """Format result for feeding back to the LLM."""
        parts = []
        
        if self.success:
            if self.stdout:
                parts.append(f"Output:\n{self.stdout}")
            if self.return_value is not None:
                parts.append(f"Return value: {self.return_value}")
            if not self.stdout and self.return_value is None:
                parts.append("Code executed successfully (no output)")
        else:
            if self.exception:
                parts.append(f"Error:\n{self.exception}")
            if self.stderr:
                parts.append(f"Stderr:\n{self.stderr}")
        
        return "\n".join(parts) if parts else "No output"


# =============================================================================
# Persistent Python Session
# =============================================================================

class PersistentSession:
    """A persistent Python REPL session that maintains state across executions."""
    
    def __init__(self, session_id: str = "default"):
        """Initialize a new session.
        
        Args:
            session_id: Unique identifier for this session
        """
        self.session_id = session_id
        self.namespace: Dict[str, Any] = {
            "__name__": "__main__",
            "__doc__": None,
        }
        self._console = InteractiveConsole(locals=self.namespace)
        self._execution_count = 0
        
        # Pre-import common modules
        self._preload_modules()
    
    def _preload_modules(self):
        """Pre-import commonly used modules into the namespace."""
        preload_code = """
import os
import sys
import json
import datetime
from pathlib import Path
"""
        try:
            exec(preload_code, self.namespace)
        except Exception as e:
            logger.warning(f"Failed to preload modules: {e}")
    
    def execute(self, code: str, timeout: float = 30.0) -> ExecutionResult:
        """Execute code in this session.
        
        Args:
            code: Python code to execute
            timeout: Maximum execution time in seconds
            
        Returns:
            ExecutionResult with output and status
        """
        import time
        start_time = time.time()
        
        self._execution_count += 1
        
        # Capture stdout and stderr
        stdout_capture = io.StringIO()
        stderr_capture = io.StringIO()
        
        result = ExecutionResult(success=True)
        
        try:
            with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                # Try to evaluate as expression first (for return values)
                try:
                    compiled = compile(code, "<input>", "eval")
                    result.return_value = eval(compiled, self.namespace)
                except SyntaxError:
                    # Not an expression, execute as statements
                    exec(code, self.namespace)
            
            result.stdout = stdout_capture.getvalue()
            result.stderr = stderr_capture.getvalue()
            
        except Exception as e:
            result.success = False
            result.exception = traceback.format_exc()
            result.stderr = stderr_capture.getvalue()
        
        result.execution_time = time.time() - start_time
        return result
    
    def get_variable(self, name: str) -> Any:
        """Get a variable from the session namespace.
        
        Args:
            name: Variable name
            
        Returns:
            Variable value or None if not found
        """
        return self.namespace.get(name)
    
    def set_variable(self, name: str, value: Any):
        """Set a variable in the session namespace.
        
        Args:
            name: Variable name
            value: Variable value
        """
        self.namespace[name] = value
    
    def clear(self):
        """Clear the session namespace (except builtins)."""
        self.namespace.clear()
        self.namespace["__name__"] = "__main__"
        self.namespace["__doc__"] = None
        self._preload_modules()
        self._execution_count = 0


# =============================================================================
# Code Interpreter
# =============================================================================

class CodeInterpreter:
    """Code interpreter with safety checks and session management."""
    
    def __init__(
        self,
        require_confirmation: Optional[List[str]] = None,
        execution_timeout: float = 30.0,
        max_iterations: int = 5
    ):
        """Initialize the code interpreter.
        
        Args:
            require_confirmation: Patterns that require user confirmation
            execution_timeout: Maximum execution time per code block
            max_iterations: Maximum ReAct loop iterations
        """
        config = get_config()
        
        self.require_confirmation = require_confirmation or config.interpreter.require_confirmation
        self.execution_timeout = execution_timeout or config.interpreter.execution_timeout_sec
        self.max_iterations = max_iterations or config.interpreter.max_iterations
        
        # Session storage
        self._sessions: Dict[str, PersistentSession] = {}
        
        # Confirmation callback (set by agent)
        self._confirmation_callback: Optional[Callable[[str, List[str]], bool]] = None
    
    def set_confirmation_callback(self, callback: Callable[[str, List[str]], bool]):
        """Set the callback for user confirmation.
        
        Args:
            callback: Function that takes (code, operations) and returns True to proceed
        """
        self._confirmation_callback = callback
    
    def get_session(self, session_id: str = "default") -> PersistentSession:
        """Get or create a session.
        
        Args:
            session_id: Session identifier
            
        Returns:
            PersistentSession instance
        """
        if session_id not in self._sessions:
            self._sessions[session_id] = PersistentSession(session_id)
        return self._sessions[session_id]
    
    def close_session(self, session_id: str):
        """Close and remove a session.
        
        Args:
            session_id: Session identifier
        """
        if session_id in self._sessions:
            del self._sessions[session_id]
    
    def check_safety(self, code: str) -> ExecutionResult:
        """Check code for dangerous or forbidden patterns.
        
        Args:
            code: Code to check
            
        Returns:
            ExecutionResult with safety analysis
        """
        result = ExecutionResult(success=True)
        
        # Check for forbidden patterns (absolute block)
        for pattern in _forbidden_re:
            if pattern.search(code):
                result.success = False
                result.exception = f"Forbidden operation detected: {pattern.pattern}"
                return result
        
        # Check for dangerous patterns (require confirmation)
        dangerous_ops = []
        for i, pattern in enumerate(_dangerous_re):
            if pattern.search(code):
                dangerous_ops.append(DANGEROUS_PATTERNS[i])
        
        # Also check configured patterns
        for pattern_str in self.require_confirmation:
            if pattern_str.lower() in code.lower():
                dangerous_ops.append(pattern_str)
        
        if dangerous_ops:
            result.requires_confirmation = True
            result.dangerous_operations = list(set(dangerous_ops))
        
        return result
    
    async def execute(
        self,
        code: str,
        session_id: str = "default",
        skip_safety_check: bool = False
    ) -> ExecutionResult:
        """Execute code with safety checks.
        
        Args:
            code: Python code to execute
            session_id: Session to use
            skip_safety_check: Skip safety checks (use with caution)
            
        Returns:
            ExecutionResult with output and status
        """
        # Safety check
        if not skip_safety_check:
            safety_result = self.check_safety(code)
            
            if not safety_result.success:
                return safety_result
            
            if safety_result.requires_confirmation:
                if self._confirmation_callback:
                    confirmed = self._confirmation_callback(
                        code, 
                        safety_result.dangerous_operations
                    )
                    if not confirmed:
                        safety_result.success = False
                        safety_result.exception = "Operation cancelled by user"
                        return safety_result
                else:
                    # No callback set, block dangerous operations
                    safety_result.success = False
                    safety_result.exception = (
                        f"Dangerous operations detected: {safety_result.dangerous_operations}. "
                        "No confirmation callback set."
                    )
                    return safety_result
        
        # Get session and execute
        session = self.get_session(session_id)
        
        # Run in thread pool to not block async event loop
        loop = asyncio.get_event_loop()
        result = await loop.run_in_executor(
            None,
            lambda: session.execute(code, self.execution_timeout)
        )
        
        return result
    
    async def execute_with_retry(
        self,
        code: str,
        session_id: str = "default",
        error_handler: Optional[Callable[[str, str], str]] = None,
        max_retries: int = 3
    ) -> ExecutionResult:
        """Execute code with automatic retry on errors.
        
        If execution fails and an error_handler is provided, it will be called
        to generate corrected code for retry.
        
        Args:
            code: Python code to execute
            session_id: Session to use
            error_handler: Function that takes (original_code, error) and returns corrected code
            max_retries: Maximum number of retry attempts
            
        Returns:
            ExecutionResult from final attempt
        """
        current_code = code
        result: Optional[ExecutionResult] = None
        
        for attempt in range(max_retries + 1):
            result = await self.execute(current_code, session_id)
            
            if result.success:
                return result
            
            if error_handler and attempt < max_retries:
                # Get corrected code from handler
                error_info = result.exception or result.stderr
                current_code = error_handler(current_code, error_info)
                logger.info(f"Retrying execution (attempt {attempt + 2})")
            else:
                break
        
        # This should never be None since we always execute at least once
        assert result is not None
        return result
    
    def inject_variable(self, session_id: str, name: str, value: Any):
        """Inject a variable into a session.
        
        Useful for providing context or data to the code.
        
        Args:
            session_id: Session identifier
            name: Variable name
            value: Variable value
        """
        session = self.get_session(session_id)
        session.set_variable(name, value)
    
    def get_variable(self, session_id: str, name: str) -> Any:
        """Get a variable from a session.
        
        Args:
            session_id: Session identifier
            name: Variable name
            
        Returns:
            Variable value or None
        """
        session = self.get_session(session_id)
        return session.get_variable(name)


# =============================================================================
# Global Interpreter Instance
# =============================================================================

_interpreter: Optional[CodeInterpreter] = None


def get_interpreter() -> CodeInterpreter:
    """Get the global interpreter instance.
    
    Returns:
        CodeInterpreter instance
    """
    global _interpreter
    
    if _interpreter is None:
        _interpreter = CodeInterpreter()
    
    return _interpreter
